#!/usr/bin/env python3

import argparse
import re
import sys
import time
from itertools import cycle

import clingo

start_time = time.time()

# GLOBAL PARAMS:
__version__ = "1.0.0"
k = 0
clingo_output = False
DEBUG = False
DICTIONARY = False

CURRENT_CONTROL = None
RESTART_STRATEGIES = {
    "luby": "L,60",
    "geometric": "x,100,1.5",
    "dynamic": "D,100,0.7",
    "fixed": "F,100",
    "none": "0",
}

# Helper function for clingo-style output
def truthValueToString(val):
    if val is True:
        return "1"
    if val is False:
        return "0"
    return "?"


class Propagator:
    def __init__(self, depth):
        self.depth = depth
        self.solver_literals = []
        self.symbols = []
        self.found = False
        self.valuation = None
        self.decision_level = None
        self.exceeded_depth = False

    def init(self, init):
        init.check_mode = clingo.PropagatorCheckMode.Fixpoint

        for atom in init.symbolic_atoms:
            init.add_watch(init.solver_literal(atom.literal))
            self.solver_literals.append(init.solver_literal(atom.literal))
            self.symbols.append(atom.symbol)
            if DICTIONARY:
                print(atom.symbol, "has solver literal", init.solver_literal(atom.literal))

    def check(self, ctl):
        if DEBUG:
            print("Current depth = ", ctl.assignment.decision_level - 1)

        if ctl.assignment.decision_level > self.depth + 1:
            self.exceeded_depth = True
            if CURRENT_CONTROL:
                CURRENT_CONTROL.interrupt()
            return

        if (ctl.assignment.decision_level == self.depth + 1) or (ctl.assignment.is_total):
            self.valuation = []
            for i in range(len(self.solver_literals)):
                truth_value = truthValueToString(ctl.assignment.value(self.solver_literals[i]))
                self.valuation.append((str(self.symbols[i]), truth_value))
            self.found = True
            self.decision_level = ctl.assignment.decision_level
            if CURRENT_CONTROL:
                CURRENT_CONTROL.interrupt()


def configure_solver(control, restart_key):
    if restart_key not in RESTART_STRATEGIES:
        raise ValueError(f"Unknown restart strategy: {restart_key}")
    control.configuration.solver[0].restarts = RESTART_STRATEGIES[restart_key]


def valuation_signature(valuation):
    return tuple(valuation)


def valuation_block_constraint(valuation):
    literals = []
    for atom, value in valuation:
        if value == "1":
            literals.append(atom)
        elif value == "0":
            literals.append(f"not {atom}")
    if not literals:
        return None
    return ":- " + ", ".join(literals) + "."


def print_valuation(valuation, idx, depth, strategy):
    bot_atoms = 0
    tot_atoms = 0
    print(f"\nValuation {idx} (k={depth}, restart={strategy}):")
    if not clingo_output:
        for atom, value in valuation:
            if value == "?":
                bot_atoms += 1
            tot_atoms += 1
            print(f"V({atom}) = {value}")
    else:
        for atom, value in valuation:
            if value == "1":
                print(atom, end=" ")
            elif value == "?":
                print("?" + atom, end=" ")
            if value == "?":
                bot_atoms += 1
            tot_atoms += 1
        print()

    print("\n" + str(depth) + "-DEPTH SATISFIABLE")
    print("\nAtoms        : " + str(tot_atoms))
    print("Bottoms      : " + str(bot_atoms))


def parse_show_signatures(path):
    signatures = set()
    pattern = re.compile(r"#show\s+([A-Za-z_][A-Za-z0-9_]*)(?:/(\d+))?")
    try:
        with open(path, "r", encoding="utf-8", errors="ignore") as handle:
            text = handle.read()
    except OSError:
        return set()
    for match in pattern.finditer(text):
        name = match.group(1)
        arity = match.group(2)
        if arity is None:
            signatures.add((name, 0))
        else:
            signatures.add((name, int(arity)))
    return signatures


def atom_signature(atom_str):
    if "(" not in atom_str:
        return atom_str, 0
    name, rest = atom_str.split("(", 1)
    args = rest.rsplit(")", 1)[0]
    if not args:
        return name, 0
    return name, len(args.split(","))


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description="Compute k-depth 3ND* valuations for ASP programs.",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument("file", type=str, help="path to lp file")
    parser.add_argument("-k", "--depth", type=int, help="depth of reasoner (default=0)", default=0)
    parser.add_argument(
        "-o",
        "--clingo-output",
        help="enables clingo-style output",
        action="store_true",
        default=True,
    )
    parser.add_argument(
        "--no-clingo-output",
        dest="clingo_output",
        action="store_false",
        help="disables clingo-style output",
    )
    parser.add_argument("--dictionary", help="display the dictionary", action="store_true")
    parser.add_argument("--debug", help="display debug information", action="store_true")
    parser.add_argument(
        "--restart-strategy",
        type=str,
        default="luby",
        help="restart strategy (luby, geometric, dynamic, fixed, none). Use comma-separated values to cycle.",
    )
    parser.add_argument(
        "--mode",
        "--enum-mode",
        type=str,
        default="all",
        choices=["all", "brave", "cautious"],
        help="output mode: all valuations, brave (true in some), cautious (true in all).",
    )
    parser.add_argument(
        "-n",
        "--models",
        type=int,
        default=0,
        help="stop after N valuations (0 = no limit)",
    )
    parser.add_argument(
        "--color",
        choices=["auto", "always", "never"],
        default="auto",
        help="colorize ?atoms in clingo-style output (default: auto)",
    )
    args = parser.parse_args()
    k = args.depth
    clingo_output = args.clingo_output
    if args.debug:
        DEBUG = True
    if args.dictionary:
        DICTIONARY = True

    if clingo_output:
        print("klingo version", __version__)
        print("Reading from", args.file)
        print("Solving...")
    else:
        print("k-lingo version", __version__)
        print("Reading from", args.file)
        print("Solving with k =", args.depth, "...\n")

    # ---------------------------------------

    restart_keys = [key.strip() for key in args.restart_strategy.split(",") if key.strip()]
    for key in restart_keys:
        if key not in RESTART_STRATEGIES:
            raise SystemExit(f"Unknown restart strategy: {key}")

    restart_cycle = cycle(restart_keys)
    show_signatures = parse_show_signatures(args.file) if clingo_output else set()
    seen = set()
    blocking_constraints = []
    valuation_index = 0
    brave_union = set()
    cautious_intersection = None
    all_atoms = None
    exhausted = False
    hit_limit = False

    solve_calls = 0
    if args.color == "always":
        colorize = True
    elif args.color == "never":
        colorize = False
    else:
        colorize = sys.stdout.isatty()

    while True:
        strategy = next(restart_cycle)
        CURRENT_CONTROL = clingo.Control(["-Wno-atom-undefined"])
        configure_solver(CURRENT_CONTROL, strategy)
        propagator = Propagator(k)
        CURRENT_CONTROL.register_propagator(propagator)
        CURRENT_CONTROL.load(args.file)
        if blocking_constraints:
            CURRENT_CONTROL.add("blocks", [], "\n".join(blocking_constraints))
        CURRENT_CONTROL.ground([("base", [])])
        if blocking_constraints:
            CURRENT_CONTROL.ground([("blocks", [])])

        solve_calls += 1
        solve_result = CURRENT_CONTROL.solve(on_model=lambda m: None)

        if propagator.exceeded_depth:
            raise SystemExit("Search exceeded k-depth; aborting.")

        if not propagator.found:
            if solve_result.unsatisfiable and valuation_index == 0:
                if clingo_output:
                    print("UNSATISFIABLE")
                else:
                    print("\nUNSATISFIABLE")
            exhausted = True
            break

        signature = valuation_signature(propagator.valuation)
        if signature in seen:
            block = valuation_block_constraint(propagator.valuation)
            if not block or block in blocking_constraints:
                if not clingo_output:
                    print("\nNo new blocking constraint for a repeated valuation; stopping to avoid loops.")
                break
            blocking_constraints.append(block)
            continue

        valuation_index += 1
        seen.add(signature)
        if clingo_output and show_signatures:
            filtered = []
            for atom, value in propagator.valuation:
                sig = atom_signature(atom)
                if sig in show_signatures:
                    filtered.append((atom, value))
        else:
            filtered = list(propagator.valuation)

        true_atoms = {atom for atom, value in filtered if value == "1"}
        brave_union |= true_atoms
        if cautious_intersection is None:
            cautious_intersection = set(true_atoms)
        else:
            cautious_intersection &= true_atoms
        if all_atoms is None:
            all_atoms = {atom for atom, _value in filtered}

        if clingo_output:
            if args.mode == "all":
                print(f"Answer: {valuation_index}")
                atoms = []
                for atom, value in filtered:
                    if value == "1":
                        atoms.append(atom)
                    elif value == "?":
                        if colorize:
                            atoms.append("\033[90m?" + atom + "\033[0m")
                        else:
                            atoms.append("?" + atom)
                print(" ".join(atoms))
            elif args.mode in {"brave", "cautious"}:
                pass
        else:
            if args.mode == "all":
                print_valuation(propagator.valuation, valuation_index, k, strategy)
        block = valuation_block_constraint(propagator.valuation)
        if block:
            if block not in blocking_constraints:
                blocking_constraints.append(block)
        else:
            if not clingo_output:
                print("\nNo defined literals to block this valuation; stopping.")
            break

        if args.models > 0 and valuation_index >= args.models:
            hit_limit = True
            break

    elapsed = time.time() - start_time
    if not exhausted:
        exhausted = not hit_limit

    if clingo_output:
        status = "SATISFIABLE" if valuation_index > 0 else "UNSATISFIABLE"
        print(status)
        if args.mode in {"brave", "cautious"}:
            total = len(all_atoms or [])
            if args.mode == "brave":
                low = len(brave_union)
                high = total
            else:
                low = 0
                high = len(cautious_intersection or [])
            print(f"Consequences [{low};{high}]")
            if args.mode == "brave":
                atoms = sorted(brave_union)
            else:
                atoms = sorted(cautious_intersection or set())
            print(f"Answer: (Time: {elapsed:.3f}s)")
            if atoms:
                print(" ".join(atoms))
            models_suffix = "" if exhausted else "+"
            print(f"\nModels       : 1{models_suffix}")
            if args.mode == "brave":
                flag = "yes" if exhausted else "unknown"
                print(f"  Brave      : {flag}")
                cons = len(brave_union)
                cons_suffix = "" if exhausted else "+"
                print(f"Consequences : {cons}{cons_suffix}")
            else:
                flag = "yes" if exhausted else "unknown"
                cons = len(cautious_intersection or []) if exhausted else 0
                cons_suffix = "" if exhausted else "+"
                print(f"  Cautious   : {flag}")
                print(f"Consequences : {cons}{cons_suffix}")
        else:
            models_suffix = "" if exhausted else "+"
            print(f"Models       : {valuation_index}{models_suffix}")
        print(f"Calls        : {solve_calls}")
        print("Time         : {:.2f}s".format(elapsed))
        print("CPU Time     : {:.2f}s".format(elapsed))
        if args.mode in {"brave", "cautious"} and not exhausted:
            print("*** Warn : (klingo): #models not 0: last model may not cover consequences.")
    else:
        print("\nTime         : {:.2f}".format(elapsed) + "s")

    if not clingo_output and args.mode in {"brave", "cautious"} and (brave_union or cautious_intersection is not None):
        if args.mode == "brave":
            atoms = brave_union
            label = "Brave consequences"
        else:
            atoms = cautious_intersection or set()
            label = "Cautious consequences"
        print(f"\n{label} (k={k}):")
        if atoms:
            print(" ".join(sorted(atoms)))
        else:
            print("(none)")
