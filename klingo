#!/usr/bin/env python3

import argparse
import re
import sys
import time
from itertools import cycle

import clingo
from clingo import ast as clingo_ast

start_time = time.time()

# GLOBAL PARAMS:
__version__ = "1.2.0"
k = 0
clingo_output = False
DEBUG = False
DICTIONARY = False

CURRENT_CONTROL = None
RESTART_STRATEGIES = {
    "luby": "L,60",
    "geometric": "x,100,1.5",
    "dynamic": "D,100,0.7",
    "fixed": "F,100",
    "none": "0",
}

# Helper function for clingo-style output
def truthValueToString(val):
    if val is True:
        return "1"
    if val is False:
        return "0"
    return "?"


class Propagator:
    def __init__(self, depth):
        self.depth = depth
        self.solver_literals = []
        self.symbols = []
        self.found = False
        self.valuation = None
        self.decision_level = None
        self.exceeded_depth = False

    def init(self, init):
        init.check_mode = clingo.PropagatorCheckMode.Fixpoint

        for atom in init.symbolic_atoms:
            init.add_watch(init.solver_literal(atom.literal))
            self.solver_literals.append(init.solver_literal(atom.literal))
            self.symbols.append(atom.symbol)
            if DICTIONARY:
                print(atom.symbol, "has solver literal", init.solver_literal(atom.literal))

    def check(self, ctl):
        if DEBUG:
            print("Current depth = ", ctl.assignment.decision_level - 1)

        if ctl.assignment.decision_level > self.depth + 1:
            self.exceeded_depth = True
            if CURRENT_CONTROL:
                CURRENT_CONTROL.interrupt()
            return

        if (ctl.assignment.decision_level == self.depth + 1) or (ctl.assignment.is_total):
            self.valuation = []
            for i in range(len(self.solver_literals)):
                truth_value = truthValueToString(ctl.assignment.value(self.solver_literals[i]))
                self.valuation.append((str(self.symbols[i]), truth_value))
            self.found = True
            self.decision_level = ctl.assignment.decision_level
            if CURRENT_CONTROL:
                CURRENT_CONTROL.interrupt()


def configure_solver(control, restart_key):
    if restart_key not in RESTART_STRATEGIES:
        raise ValueError(f"Unknown restart strategy: {restart_key}")
    control.configuration.solver[0].restarts = RESTART_STRATEGIES[restart_key]


def valuation_signature(valuation):
    return tuple(valuation)


def valuation_block_constraint(valuation):
    literals = []
    for atom, value in valuation:
        if value == "1":
            literals.append(atom)
        elif value == "0":
            literals.append(f"not {atom}")
    if not literals:
        return None
    return ":- " + ", ".join(literals) + "."


def format_atom(atom, tag_map, colorize):
    if atom not in tag_map:
        return atom
    tag = tag_map[atom]
    if colorize:
        color = {
            "bnm": "\033[34m",
        }[tag]
        return f"{color}{atom}\033[0m"
    prefix = {
        "bnm": "[b]",
    }[tag]
    return f"{prefix}{atom}"


def print_valuation(valuation, idx, depth, strategy, tag_map=None, colorize=False):
    bot_atoms = 0
    tot_atoms = 0
    tag_map = tag_map or {}
    print(f"\nValuation {idx} (k={depth}, restart={strategy}):")
    if not clingo_output:
        for atom, value in valuation:
            if value == "?":
                bot_atoms += 1
            tot_atoms += 1
            if atom in tag_map:
                print(f"V({format_atom(atom, tag_map, colorize)}) = {value}")
            else:
                print(f"V({atom}) = {value}")
    else:
        for atom, value in valuation:
            if value == "1":
                if atom in tag_map:
                    print(format_atom(atom, tag_map, colorize), end=" ")
                else:
                    print(atom, end=" ")
            elif value == "?":
                print("?" + atom, end=" ")
            if value == "?":
                bot_atoms += 1
            tot_atoms += 1
        print()

    print("\n" + str(depth) + "-DEPTH SATISFIABLE")
    print("\nAtoms        : " + str(tot_atoms))
    print("Bottoms      : " + str(bot_atoms))


def parse_show_signatures(paths):
    signatures = set()
    pattern = re.compile(r"#show\s+([A-Za-z_][A-Za-z0-9_]*)(?:/(\d+))?")
    for path in paths:
        try:
            with open(path, "r", encoding="utf-8", errors="ignore") as handle:
                text = handle.read()
        except OSError:
            continue
        for match in pattern.finditer(text):
            name = match.group(1)
            arity = match.group(2)
            if arity is None:
                signatures.add((name, 0))
            else:
                signatures.add((name, int(arity)))
    return signatures


def _collect_constants_from_symbol(sym, constants):
    if sym.type in (clingo.SymbolType.Number, clingo.SymbolType.String):
        constants.add(sym)
    elif sym.type == clingo.SymbolType.Function:
        if len(sym.arguments) == 0:
            constants.add(sym)
        else:
            for arg in sym.arguments:
                _collect_constants_from_symbol(arg, constants)


def _collect_constants_from_term(term, constants):
    if term.ast_type == clingo_ast.ASTType.SymbolicTerm:
        _collect_constants_from_symbol(term.symbol, constants)
    elif term.ast_type == clingo_ast.ASTType.Function:
        if not term.arguments:
            constants.add(clingo.Function(term.name))
        else:
            for arg in term.arguments:
                _collect_constants_from_term(arg, constants)


def _collect_signatures_constants(paths):
    signatures = set()
    constants = set()

    def walk(node):
        yield node
        try:
            keys = node.keys()
        except Exception:
            keys = []
        for key in keys:
            val = getattr(node, key)
            if isinstance(val, clingo_ast.AST):
                yield from walk(val)
            elif isinstance(val, (list, clingo_ast.ASTSequence)):
                for item in val:
                    if isinstance(item, clingo_ast.AST):
                        yield from walk(item)

    def visit(node):
        for sub in walk(node):
            if sub.ast_type == clingo_ast.ASTType.SymbolicAtom:
                sym_node = sub.symbol
                target = None
                if sym_node.ast_type == clingo_ast.ASTType.Function:
                    target = sym_node
                elif sym_node.ast_type == clingo_ast.ASTType.UnaryOperation:
                    if sym_node.operator_type == clingo_ast.UnaryOperator.Minus:
                        if sym_node.argument.ast_type == clingo_ast.ASTType.Function:
                            target = sym_node.argument
                if target is not None:
                    signatures.add((target.name, len(target.arguments)))
                    for arg in target.arguments:
                        _collect_constants_from_term(arg, constants)

    clingo_ast.parse_files(paths, visit)
    return signatures, constants


def _cartesian_args(items, arity):
    if arity == 0:
        return [[]]
    if not items:
        return []
    if arity == 1:
        return [[item] for item in items]
    tails = _cartesian_args(items, arity - 1)
    out = []
    for item in items:
        for tail in tails:
            out.append([item] + tail)
    return out


def add_classical_totality(control, paths):
    signatures, constants = _collect_signatures_constants(paths)
    if not signatures:
        return
    const_list = sorted(constants, key=str)
    lines = []
    for name, arity in sorted(signatures):
        if name.startswith("#"):
            continue
        if arity == 0:
            lines.append(f"1 {{ {name}; -{name} }} 1.")
            continue
        args_sets = _cartesian_args(const_list, arity)
        for args in args_sets:
            args_str = ",".join(str(a) for a in args)
            lines.append(f"1 {{ {name}({args_str}); -{name}({args_str}) }} 1.")
    if lines:
        control.add("classical", [], "\n".join(lines))


def _rewrite_body_literal_as_naf(lit):
    if lit.atom.ast_type != clingo_ast.ASTType.SymbolicAtom:
        return lit
    sym = lit.atom.symbol
    if sym.ast_type != clingo_ast.ASTType.UnaryOperation:
        return lit
    if sym.operator_type != clingo_ast.UnaryOperator.Minus:
        return lit
    if lit.sign != clingo_ast.Sign.NoSign:
        return lit
    base = sym.argument
    new_atom = clingo_ast.SymbolicAtom(base)
    return clingo_ast.Literal(lit.location, clingo_ast.Sign.Negation, new_atom)


def _is_strong_negation(atom_str):
    return atom_str.startswith("-") and len(atom_str) > 1 and atom_str[1].isalpha()


def _completion_core_closure(paths, valuation):
    """
    Non-branching completion over the already decided core.
    Rules are read in completion form (body strong negation rewritten to NAF).
    Unsupported heads/bodies (e.g., choice/disjunction/aggregates) are ignored.
    """
    rules = []

    def on_ast(node):
        if node.ast_type != clingo_ast.ASTType.Rule:
            return
        # Keep only normal rules with a symbolic literal head.
        if node.head.ast_type != clingo_ast.ASTType.Literal:
            return
        if node.head.sign != clingo_ast.Sign.NoSign:
            return
        if node.head.atom.ast_type != clingo_ast.ASTType.SymbolicAtom:
            return
        head_atom = str(node.head.atom.symbol)

        pos = []
        neg = []
        for lit in node.body:
            lit = _rewrite_body_literal_as_naf(lit)
            if lit.atom.ast_type != clingo_ast.ASTType.SymbolicAtom:
                return
            atom = str(lit.atom.symbol)
            if lit.sign == clingo_ast.Sign.NoSign:
                pos.append(atom)
            elif lit.sign == clingo_ast.Sign.Negation:
                neg.append(atom)
            else:
                return
        rules.append((head_atom, tuple(pos), tuple(neg)))

    clingo_ast.parse_files(paths, on_ast)

    true_atoms = {atom for atom, value in valuation if value == "1"}

    # Deterministic closure from decided core:
    # - positive body atoms must be in the current true set
    # - not p is satisfied iff p is not currently true
    changed = True
    while changed:
        changed = False
        for head, pos, neg in rules:
            if head in true_atoms:
                continue
            if all(atom in true_atoms for atom in pos) and all(atom not in true_atoms for atom in neg):
                true_atoms.add(head)
                changed = True

    neg_true = {atom for atom in true_atoms if _is_strong_negation(atom)}
    return true_atoms, neg_true


def apply_default_completion(valuation, paths):
    undecided = [atom for atom, value in valuation if value == "?" and not _is_strong_negation(atom)]
    if not undecided:
        return valuation, set()
    pos_all, neg_all = _completion_core_closure(paths, valuation)
    if not pos_all and not neg_all:
        return valuation, set()
    index = {atom: idx for idx, (atom, _value) in enumerate(valuation)}
    updated = list(valuation)
    bnm_atoms = set()
    for atom in undecided:
        neg_atom = "-" + atom
        has_pos = atom in pos_all
        has_neg = neg_atom in neg_all
        if has_pos and not has_neg:
            idx = index.get(atom)
            if idx is not None:
                updated[idx] = (atom, "1")
                bnm_atoms.add(atom)
            neg_idx = index.get(neg_atom)
            if neg_idx is not None and updated[neg_idx][1] == "?":
                updated[neg_idx] = (neg_atom, "0")
                bnm_atoms.add(neg_atom)
        elif has_neg and not has_pos:
            idx = index.get(atom)
            if idx is not None:
                updated[idx] = (atom, "0")
                bnm_atoms.add(atom)
            neg_idx = index.get(neg_atom)
            if neg_idx is not None and updated[neg_idx][1] == "?":
                updated[neg_idx] = (neg_atom, "1")
                bnm_atoms.add(neg_atom)
    return updated, bnm_atoms

def atom_signature(atom_str):
    if "(" not in atom_str:
        return atom_str, 0
    name, rest = atom_str.split("(", 1)
    args = rest.rsplit(")", 1)[0]
    if not args:
        return name, 0
    return name, len(args.split(","))


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description="Compute k-depth valuations for ASP programs.",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument("files", nargs="+", type=str, help="path(s) to base lp file(s)")
    parser.add_argument("-k", "--depth", type=int, help="depth of reasoner (default=0)", default=0)
    parser.add_argument(
        "-o",
        "--clingo-output",
        help="enables clingo-style output",
        action="store_true",
        default=True,
    )
    parser.add_argument(
        "--no-clingo-output",
        dest="clingo_output",
        action="store_false",
        help="disables clingo-style output",
    )
    mode_group = parser.add_mutually_exclusive_group()
    mode_group.add_argument(
        "--3nd-star",
        dest="solver_mode",
        action="store_const",
        const="3nd-star",
        help="3ND* mode: original ASP approximation (default)",
    )
    mode_group.add_argument(
        "--3nd",
        dest="solver_mode",
        action="store_const",
        const="3nd",
        help="3ND mode: totality axioms only (no completion)",
    )
    mode_group.add_argument(
        "--bnm",
        dest="solver_mode",
        action="store_const",
        const="bnm",
        help="BNM mode: totality axioms + bounded non-monotonic completion",
    )
    parser.set_defaults(solver_mode="3nd-star")
    parser.add_argument("--dictionary", help="display the dictionary", action="store_true")
    parser.add_argument("--debug", help="display debug information", action="store_true")
    parser.add_argument(
        "--restart-strategy",
        type=str,
        default="luby",
        help="restart strategy (luby, geometric, dynamic, fixed, none). Use comma-separated values to cycle.",
    )
    parser.add_argument(
        "--mode",
        type=str,
        default="all",
        choices=["all", "brave", "cautious"],
        help="output mode: all valuations, brave (true in some), cautious (true in all).",
    )
    parser.add_argument(
        "-n",
        "--models",
        type=int,
        default=0,
        help="stop after N valuations (0 = no limit)",
    )
    parser.add_argument(
        "--color",
        choices=["auto", "always", "never"],
        default="auto",
        help="colorize ?atoms in clingo-style output (default: auto)",
    )
    args = parser.parse_args()
    k = args.depth
    clingo_output = args.clingo_output
    if args.debug:
        DEBUG = True
    if args.dictionary:
        DICTIONARY = True

    all_paths = list(args.files)
    if clingo_output:
        print("klingo version", __version__)
        print("Reading from", ", ".join(all_paths))
        print("Solving...")
    else:
        print("k-lingo version", __version__)
        print("Reading from", ", ".join(all_paths))
        print("Solving with k =", args.depth, "...\n")

    # ---------------------------------------

    restart_keys = [key.strip() for key in args.restart_strategy.split(",") if key.strip()]
    for key in restart_keys:
        if key not in RESTART_STRATEGIES:
            raise SystemExit(f"Unknown restart strategy: {key}")

    restart_cycle = cycle(restart_keys)
    show_signatures = parse_show_signatures(all_paths) if clingo_output else set()
    seen = set()
    blocking_constraints = []
    valuation_index = 0
    brave_union = set()
    cautious_intersection = None
    all_atoms = None
    tag_map_for_summary = {}
    legend_flags = set()
    exhausted = False
    hit_limit = False

    solve_calls = 0
    if args.color == "always":
        colorize = True
    elif args.color == "never":
        colorize = False
    else:
        colorize = sys.stdout.isatty()

    while True:
        strategy = next(restart_cycle)
        CURRENT_CONTROL = clingo.Control(["-Wno-atom-undefined"])
        configure_solver(CURRENT_CONTROL, strategy)
        propagator = Propagator(k)
        CURRENT_CONTROL.register_propagator(propagator)
        for path in all_paths:
            CURRENT_CONTROL.load(path)
        needs_classical = args.solver_mode in {"3nd", "bnm"}
        if needs_classical:
            add_classical_totality(CURRENT_CONTROL, all_paths)
        if blocking_constraints:
            CURRENT_CONTROL.add("blocks", [], "\n".join(blocking_constraints))
        parts = [("base", [])]
        if needs_classical:
            parts.append(("classical", []))
        CURRENT_CONTROL.ground(parts)
        if blocking_constraints:
            CURRENT_CONTROL.ground([("blocks", [])])

        solve_calls += 1
        solve_result = CURRENT_CONTROL.solve(on_model=lambda m: None)

        if propagator.exceeded_depth:
            raise SystemExit("Search exceeded k-depth; aborting.")

        if not propagator.found:
            if solve_result.unsatisfiable and valuation_index == 0:
                if clingo_output:
                    print("UNSATISFIABLE")
                else:
                    print("\nUNSATISFIABLE")
            exhausted = True
            break

        signature = valuation_signature(propagator.valuation)
        if signature in seen:
            block = valuation_block_constraint(propagator.valuation)
            if not block or block in blocking_constraints:
                if not clingo_output:
                    print("\nNo new blocking constraint for a repeated valuation; stopping to avoid loops.")
                break
            blocking_constraints.append(block)
            continue

        valuation_index += 1
        seen.add(signature)
        base_valuation = propagator.valuation
        completed_valuation = base_valuation
        bnm_atoms = set()
        if args.solver_mode == "bnm":
            completed_valuation, bnm_atoms = apply_default_completion(base_valuation, all_paths)
        tag_map = {}
        for atom in bnm_atoms:
            tag_map[atom] = "bnm"
        if clingo_output and show_signatures:
            filtered = []
            for atom, value in completed_valuation:
                sig = atom_signature(atom)
                if sig in show_signatures:
                    filtered.append((atom, value))
        else:
            filtered = list(completed_valuation)

        true_atoms = {atom for atom, value in filtered if value == "1"}
        for atom, value in filtered:
            if value == "?":
                legend_flags.add("?")
            if atom in tag_map:
                legend_flags.add(tag_map[atom])
        if tag_map:
            for atom, value in filtered:
                if value == "1" and atom in tag_map:
                    tag_map_for_summary[atom] = tag_map[atom]
        brave_union |= true_atoms
        if cautious_intersection is None:
            cautious_intersection = set(true_atoms)
        else:
            cautious_intersection &= true_atoms
        if all_atoms is None:
            all_atoms = {atom for atom, _value in filtered}

        if clingo_output:
            if args.mode == "all":
                print(f"Answer: {valuation_index}")
                atoms = []
                for atom, value in filtered:
                    if value == "1":
                        if atom in tag_map:
                            atoms.append(format_atom(atom, tag_map, colorize))
                        else:
                            atoms.append(atom)
                    elif value == "?":
                        if colorize:
                            atoms.append("\033[90m?" + atom + "\033[0m")
                        else:
                            atoms.append("?" + atom)
                print(" ".join(atoms))
            elif args.mode in {"brave", "cautious"}:
                pass
        else:
            if args.mode == "all":
                print_valuation(completed_valuation, valuation_index, k, strategy, tag_map, colorize)
        block = valuation_block_constraint(base_valuation)
        if block:
            if block not in blocking_constraints:
                blocking_constraints.append(block)
        else:
            if not clingo_output:
                print("\nNo defined literals to block this valuation; stopping.")
            break

        if args.models > 0 and valuation_index >= args.models:
            hit_limit = True
            break

    elapsed = time.time() - start_time
    if not exhausted:
        exhausted = not hit_limit

    if clingo_output:
        status = "SATISFIABLE" if valuation_index > 0 else "UNSATISFIABLE"
        print(status)
        if args.mode in {"brave", "cautious"}:
            total = len(all_atoms or [])
            if args.mode == "brave":
                low = len(brave_union)
                high = total
            else:
                low = 0
                high = len(cautious_intersection or [])
            print(f"Consequences [{low};{high}]")
            if args.mode == "brave":
                atoms = sorted(brave_union)
            else:
                atoms = sorted(cautious_intersection or set())
            print(f"Answer: (Time: {elapsed:.3f}s)")
            if atoms:
                if tag_map_for_summary:
                    colored = []
                    for atom in atoms:
                        if atom in tag_map_for_summary:
                            colored.append(format_atom(atom, tag_map_for_summary, colorize))
                        else:
                            colored.append(atom)
                    print(" ".join(colored))
                else:
                    print(" ".join(atoms))
            models_suffix = "" if exhausted else "+"
            print(f"\nModels       : 1{models_suffix}")
            if args.mode == "brave":
                flag = "yes" if exhausted else "unknown"
                print(f"  Brave      : {flag}")
                cons = len(brave_union)
                cons_suffix = "" if exhausted else "+"
                print(f"Consequences : {cons}{cons_suffix}")
            else:
                flag = "yes" if exhausted else "unknown"
                cons = len(cautious_intersection or []) if exhausted else 0
                cons_suffix = "" if exhausted else "+"
                print(f"  Cautious   : {flag}")
                print(f"Consequences : {cons}{cons_suffix}")
        else:
            models_suffix = "" if exhausted else "+"
            print(f"Models       : {valuation_index}{models_suffix}")
        print(f"Calls        : {solve_calls}")
        print("Time         : {:.2f}s".format(elapsed))
        print("CPU Time     : {:.2f}s".format(elapsed))
        if args.mode in {"brave", "cautious"} and not exhausted:
            print("*** Warn : (klingo): #models not 0: last model may not cover consequences.")
    else:
        print("\nTime         : {:.2f}".format(elapsed) + "s")

    if not clingo_output and args.mode in {"brave", "cautious"} and (brave_union or cautious_intersection is not None):
        if args.mode == "brave":
            atoms = brave_union
            label = "Brave consequences"
        else:
            atoms = cautious_intersection or set()
            label = "Cautious consequences"
        print(f"\n{label} (k={k}):")
        if atoms:
            if tag_map_for_summary:
                colored = []
                for atom in sorted(atoms):
                    if atom in tag_map_for_summary:
                        colored.append(format_atom(atom, tag_map_for_summary, colorize))
                    else:
                        colored.append(atom)
                print(" ".join(colored))
            else:
                print(" ".join(sorted(atoms)))
        else:
            print("(none)")

    if legend_flags:
        parts = []
        if "?" in legend_flags:
            parts.append("?=undefined")
        if "bnm" in legend_flags:
            parts.append("blue=bnm" if colorize else "[b]=bnm")
        if parts:
            print("Legend: " + ", ".join(parts))
